
# Build Docker image based on Dockerfile in local repository
docker build --rm -t brentvdwijdeven/pyspark-docker-test .

# Run docker image as container


# Run main.py in docker container
docker run --platform linux/amd64 --entrypoint /bin/sh -itd -v $(pwd):/job brentvdwijdeven/pyspark-docker-test

# option: docker run --platform linux/amd64  -v $(pwd):/job brentvdwijdeven/pyspark-docker-test main.py

# docker run --platform linux/amd64 -v $(pwd):/job brentvdwijdeven/pyspark-docker-test



# Start existing container and open bash file
docker start <container_id>
docker exec -t -i <container_id> /bin/bash


# Start existing container and run command
docker start <container_id>
docker exec -it <container name> <command>




docker start clever_cartwright
docker exec -t -i clever_cartwright /bin/bash



If you override the entrypoint to the container with a shell, like sh or bash, and run the container with the -itd switches, Docker will run the container, detach it (run it in the background), and attach an interactive terminal. Note that this won’t run the container’s default entrypoint script, but run a shell instead. Effectively, you will have a container that stays running permanently. 
For example: docker run --entrypoint /bin/sh -itd mycontainer:latest

# THIS COMMAND WORKS! TO KEEP CONTAINER RUNNING IN THE BACKGROUND

# docker run --platform linux/amd64 --entrypoint /bin/sh -itd -v $(pwd):/job brentvdwijdeven/pyspark-docker-test	

# Open shell and run following python file!
python3 main.py


# This runs the entire application!




# start existing container (requirement: run docker with --entrypoint /bin/sh -itd argument)
# Then starting container also keeps it running!
docker start <containter_id>
